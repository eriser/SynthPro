\section{Tests et Validation}

\subsection{Introduction}

Afin
d`assurer une stabilité et une fiabilité optimales, nous avons décidé d'effectuer des tests sur les principales classes de l'abstraction. Il s'est agi de tests unitaires pour la plupart des composants (les \verb!Ports! et l'\verb!AudioDeviceProvider!)
et le \verb!Sequencer!, grâce à la mise en place de bouchons~;
ainsi que des tests fonctionnels pour les modules le permettant.
Pour cela, nous avons utilisé le \emph{framework} de tests
unitaires de Qt.

\subsection{WaveGenerator}

\subsubsection{TestWaveGeneratorEmpty}

Avant de tester la génération des ondes sonores, nous avons dû
vérifier qu'une génération simple fonctionnait correctement. Nous
avons donc créé une \verb!WaveGeneratorEmpty!, sous-classe de
\verb!WaveGenerator!, qui ne sait que remplir un buffer nul. Ce
test instancie donc ce générateur, lance la génération et vérifie
que buffer de sortie contient bien des 0.

\subsubsection{TestWaveGeneratorSinus, TestWaveGeneratorSquare, TestWaveGeneratorSaw, TestWaveGeneratorTriangle}

Tester que la production d'ondes est correcte n'est pas aisé. On
peut passer par l'étude des signaux générés, mais cela demande un
travail de traitement du signal important qui ne nous paraissait
pas forcément utile, ni très pertinent : l'étude des signaux peut
être bien plus sujette aux erreurs que la génération d'ondes
elle-même.

Notre méthode de test a donc consisté à générer une onde et à la
sauvegarder dans un fichier WAV grâce au module \verb!WavRecorder!.
L'écoute et la visualisation du signal sous un logiciel tel que
Audacity ou Soundforge nous indique si le résultat parait
conforme.

Nous avons poussé l'étude plus loin en passant les échantillons
sous un accordeur virtuel : la fréquence générée est alors affichée
et il nous est alors possible de savoir si le signal a la fréquence
désirée :

\begin{figure}[htb]
\centering
\includegraphics[width=17cm]{../img/png/testWaveGeneratorSinus.png}
\caption{Vérification des ondes générées grace à d'autres logiciels}
\end{figure}

Nos tests se contentent donc de générer un buffer, de le
sauvegarder, et renvoient un résultat à vrai.

\subsection{VCF}

\subsubsection{Test VCF}

Le test du \verb!VCF! consiste à lier une instance de \verb!VCO! à
un \verb!VCF!. Le VCO ne produira qu'une onde de type \verb!Empty!,
donc ne produisant que des 0. Nous utilisons le filtre
\verb!FilterIncrement! qui se contente d'ajouter 1 à toute valeur
du buffer s'entrée si elle est positive, ou --1 si elle est
négative. Le test s'assure que le buffer de sortie du \verb!VCF! ne
contient que des 1.

\subsubsection{Les filtres}

Il n'est pas possible de tester simplement les filtres. Tout comme
pour les \verb!WaveGenerators!, il faudrait décomposer le signal
afin de tester son intégrité. Cependant, là où la génération
fournie par les \verb!WaveGenerators! pouvait être étudiée par la
suite sous des logiciels tels que Soundforge ou Audacity, il n'en
est pas de même pour les filtres. Nous avons donc décidé de se fier
à l'écoute du signal.

\subsection{Test WavRecorder}

Le test du \verb!WavRecorder! consiste à relier un \verb!VCO!
utilisant le \verb!WaveGeneratorSquare!, produisant une forme
d'onde carrée à periode fixe, à l'entrée du \verb!WavRecorder!,
dans un fichier donné, en précisant un nombre défini d'itérations
au \verb!WavRecorder! afin qu'il ferme le fichier de sortie au bout
de ces itérations.

Une fois l'enregistrement terminé, on ouvre le fichier en lecture,
puis on passe le header du fichier WAV, et l'on s'assure que l'on
ne trouve bien que deux valeurs différentes (front
montant/descendant) jusqu'à la fin du fichier.

\subsection{Test WavLooper}

Le test du \verb!WavLooper! consiste à charger un fichier
\verb!WAV! ne comportant que deux valeurs différentes, le faire
lire ce fichier, puis de vérifier que la sortie du buffer ne
comporte qu'une suite de deux valeurs.

